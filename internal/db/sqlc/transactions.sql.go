// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transactions.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getTransactionByHash = `-- name: GetTransactionByHash :one
SELECT
    transaction_hash,
    block_number,
    timestamp,
    gas_used,
    gas_price_wei,
    transaction_fee_eth,
    transaction_fee_usdt,
    eth_usdt_price
FROM transactions
WHERE transaction_hash = $1
`

func (q *Queries) GetTransactionByHash(ctx context.Context, transactionHash string) (Transactions, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByHash, transactionHash)
	var i Transactions
	err := row.Scan(
		&i.TransactionHash,
		&i.BlockNumber,
		&i.Timestamp,
		&i.GasUsed,
		&i.GasPriceWei,
		&i.TransactionFeeEth,
		&i.TransactionFeeUsdt,
		&i.EthUsdtPrice,
	)
	return i, err
}

const getTransactionsByBlockNumber = `-- name: GetTransactionsByBlockNumber :many
SELECT
    transaction_hash,
    block_number,
    timestamp,
    gas_used,
    gas_price_wei,
    transaction_fee_eth,
    transaction_fee_usdt,
    eth_usdt_price
FROM transactions
WHERE block_number = $1
ORDER BY timestamp DESC
`

func (q *Queries) GetTransactionsByBlockNumber(ctx context.Context, blockNumber int64) ([]Transactions, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByBlockNumber, blockNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transactions
	for rows.Next() {
		var i Transactions
		if err := rows.Scan(
			&i.TransactionHash,
			&i.BlockNumber,
			&i.Timestamp,
			&i.GasUsed,
			&i.GasPriceWei,
			&i.TransactionFeeEth,
			&i.TransactionFeeUsdt,
			&i.EthUsdtPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByTimeRange = `-- name: GetTransactionsByTimeRange :many
SELECT
    transaction_hash,
    block_number,
    timestamp,
    gas_used,
    gas_price_wei,
    transaction_fee_eth,
    transaction_fee_usdt,
    eth_usdt_price
FROM transactions
WHERE timestamp BETWEEN $1 AND $2
ORDER BY timestamp DESC
`

type GetTransactionsByTimeRangeParams struct {
	Timestamp   time.Time `json:"timestamp"`
	Timestamp_2 time.Time `json:"timestamp_2"`
}

func (q *Queries) GetTransactionsByTimeRange(ctx context.Context, arg GetTransactionsByTimeRangeParams) ([]Transactions, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionsByTimeRange, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transactions
	for rows.Next() {
		var i Transactions
		if err := rows.Scan(
			&i.TransactionHash,
			&i.BlockNumber,
			&i.Timestamp,
			&i.GasUsed,
			&i.GasPriceWei,
			&i.TransactionFeeEth,
			&i.TransactionFeeUsdt,
			&i.EthUsdtPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTransaction = `-- name: InsertTransaction :exec
INSERT INTO transactions (
    transaction_hash,
    block_number,
    timestamp,
    gas_used,
    gas_price_wei,
    transaction_fee_eth,
    transaction_fee_usdt,
    eth_usdt_price
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
`

type InsertTransactionParams struct {
	TransactionHash    string          `json:"transaction_hash"`
	BlockNumber        int64           `json:"block_number"`
	Timestamp          time.Time       `json:"timestamp"`
	GasUsed            int64           `json:"gas_used"`
	GasPriceWei        int64           `json:"gas_price_wei"`
	TransactionFeeEth  sql.NullFloat64 `json:"transaction_fee_eth"`
	TransactionFeeUsdt sql.NullFloat64 `json:"transaction_fee_usdt"`
	EthUsdtPrice       sql.NullFloat64 `json:"eth_usdt_price"`
}

func (q *Queries) InsertTransaction(ctx context.Context, arg InsertTransactionParams) error {
	_, err := q.db.ExecContext(ctx, insertTransaction,
		arg.TransactionHash,
		arg.BlockNumber,
		arg.Timestamp,
		arg.GasUsed,
		arg.GasPriceWei,
		arg.TransactionFeeEth,
		arg.TransactionFeeUsdt,
		arg.EthUsdtPrice,
	)
	return err
}
